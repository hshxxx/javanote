# 文件的上传和下载

## 文件上传

### 前提条件

1. 必须用form标签，method为post
2. enctype属性必须为 multipart/form-data
3. input标签type属性为file
4. 服务端编写接收代码

```
<form action="" method="post" enctype="multipart/form-data">
    <input type="file">
</form>
```

multipart/form-data ： 表示表单提交的数据是以多段的形式进行拼接（form表单中每一个表单项就是一个分段），然后以二进制流的形式发送给服务器

### jar包

需要使用apache公司的两个jar包

![image-20201028205000668](C:\Users\xpty\AppData\Roaming\Typora\typora-user-images\image-20201028205000668.png)

将要用到的两个类

1. ServletFileUpload 类
2. FileItem 类

### 实例

1. 创建FileTest 类继承 HttpServlet

   ```java
   public class FileTest extends HttpServlet {
       @Override
       protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           //是否为多段数据
           if(ServletFileUpload.isMultipartContent(req)){
               //创建FileItemFactory的实现类，FileItemFactory是一个接口
               FileItemFactory diskFileItemFactory = new DiskFileItemFactory();
               //创建用于解析上传数据的工具类ServletFileUpload类
               ServletFileUpload servletFileUpload = new ServletFileUpload(diskFileItemFactory);
               try {
                   //解析表单数据，得到每一个表单项FileItem
                   List<FileItem> list = servletFileUpload.parseRequest(req);
                   //循环判断每一个表单项是普通类型，还是文件类型
                   for (FileItem fileItem : list) {
                       if(fileItem.isFormField()){
                           //普通类型
                           System.out.println("表单项的name属性"+fileItem.getFieldName());
                           System.out.println("表单项的value属性"+fileItem.getString("utf-8"));
                       }else {
                           //文件类型
                           System.out.println("表单项的name属性"+fileItem.getFieldName());
                           System.out.println("上传的文件名"+fileItem.getName());
                           //将上传的文件写入到本地
                           fileItem.write(new File("C:\\Users\\xpty\\Desktop"+fileItem.getName()));
                       }
                   }
   
   
               } catch (Exception e) {
                   e.printStackTrace();
               }
           }else{
   
           }
       }
   
   }
   表单项的name属性name
   表单项的value属性xxx
   表单项的name属性page
   上传的文件名201188164636.jpg
   ```

2. jsp

   ```jsp
   <body>
       <form action="http://localhost:8080/jstl_war_exploded/fileTest" method="post" enctype="multipart/form-data">
           姓名：<input type="text" name="name">
           图片：<input type="file" name="page">
           <input type="submit" value="上传">
       </form>
   </body>
   ```

3. web.xml中配置FileTest类

## 文件下载

顺序应该是 1 2 4 5 3

![image-20201028211932342](C:\Users\xpty\AppData\Roaming\Typora\typora-user-images\image-20201028211932342.png)

### 实例

1. 创建 FileDownloadTest 类继承 HttpServlet

   ```java
   public class FileDownloadTest extends HttpServlet {  
   	@Override
       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           //1.获取下载的文件名
           String downloadFileName = "1.jpg";
           //2.读取要下载的文件，通过把他加入SerlvetContext实现
           ServletContext servletContext = getServletContext();
           //4.在回传数据之前告诉客户端返回的数据类型
           //获取要下载的文件类型
           String mimeType = servletContext.getMimeType("/resource/" + downloadFileName);
           resp.setContentType(mimeType);
           //5.告诉客户端这是用来下载的
           //Content-Disposition响应头，告诉客户端如何处理收到的数据
           //attachement 表示附件，用来下载
           //filename= 表示客户端下载时显示的文件名，可以和本地的文件名不同
           //URLEncoder 表示url编码，解决中文乱码，仅适合谷歌和ie浏览器
           //BASE64Encoder 解决火狐浏览器的中文编码问题
           if(req.getHeader("User-Agent").contains("Firefox")){
               //浏览器是火狐
               resp.setHeader("Content-Disposition","attachement;filename=?UTF-8?B?"+ new BASE64Encoder().encode("中国.jpg".getBytes())+"?=");
   
           }else {
               //浏览器是ie或谷歌
               resp.setHeader("Content-Disposition","attachement;filename="+ URLEncoder.encode("中国.jpg", "UTF-8"));
           }
   
           //3.把下载的内容回传给客户端
           //获取本地文件的输入流
           InputStream resourceAsStream = servletContext.getResourceAsStream("/resource/" + downloadFileName);
           //获取输出流
           ServletOutputStream outputStream = resp.getOutputStream();
           //将本地文件的输入流写入到response的输出流中
           IOUtils.copy(resourceAsStream,outputStream);
   
       }
   }
   //当访问页面时会在浏览器左下方下载这个图片
   ```

2. web.xml中配置